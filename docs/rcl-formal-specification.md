# Rich Communication Language (RCL) - Formal Specification

## 1. Introduction

This document provides the formal specification for the Rich Communication Language (RCL) using an Extended Backus-Naur Form (EBNF)-like notation. This specification is derived from the Langium grammar files and the design decisions outlined in the `rcl-implementation-plan-2.md`.

Its primary purpose is to define the valid syntax of an RCL document. Semantic rules, error recovery, and the precise behavior of the underlying expression language are outside the scope of this EBNF specification and are covered by other parts of the language design (e.g., validators, interpreter/transpiler logic).

### Notation Conventions:

-   `RuleName ::= Definition` : Defines a rule.
-   `'literal'` : Represents a literal string or keyword (e.g., `'Agent'`, `':'`).
-   `TERMINAL_NAME` : Represents a terminal symbol, a basic token recognized by the lexer (e.g., `IDENTIFIER`, `STRING`).
-   `RuleName` : (When on the right-hand side) Represents a non-terminal symbol, a reference to another rule (e.g., `AgentDefinition`, `SimpleValue`).
-   `A | B` : Represents an alternative (A or B). Parsers typically attempt to match alternatives in the order they are listed or use lookahead to disambiguate.
-   `(A B)` : Represents a sequence of A followed by B.
-   `A?` : Represents zero or one occurrence of A (optional).
-   `A*` : Represents zero or more occurrences of A.
-   `A+` : Represents one or more occurrences of A.
-   `// comment` : Explanatory comments.

_Note on AST Mapping:_ While this EBNF does not explicitly use `property_name: RuleCall` syntax (common in some grammar tools like Langium), it is implied that in a corresponding Abstract Syntax Tree (AST), sequenced elements or named terminals/non-terminals would map to named properties of the AST node for the rule. For example, `Parameter ::= IDENTIFIER ':' SimpleValue` would likely result in an AST node for `Parameter` with properties corresponding to the captured `IDENTIFIER` and `SimpleValue`.

## 2. Lexical Specification (Terminals)

These are the fundamental building blocks (tokens) of the RCL, recognized by the lexer.

### 2.1 Indentation Terminals (Synthetic)
These tokens are not directly present as characters in the input text but are generated by the lexer based on changes in leading whitespace relative to the current block's indentation level.
```ebnf
INDENT ::= /* Marks a significant increase in indentation level. */
DEDENT ::= /* Marks a significant decrease in indentation level, closing one or more blocks. */
```

### 2.2 Hidden Terminals (Ignored by the parser but consumed by the lexer)
These tokens are recognized but do not form part of the structural syntax passed to the parser, except for their role in separating other tokens and influencing `INDENT`/`DEDENT` generation.
```ebnf
WS ::= /[\t ]+/                         // Whitespace (one or more spaces or tabs), does not include newlines.
NL ::= /[\r\n]+/                        // Newlines (one or more).
SL_COMMENT ::= /#.*/                    // Single-line comments (from '#' to end of line).
```
_Note on Whitespace within Rules:_ The `WS` hidden terminal allows for optional spaces and tabs between any adjacent non-hidden terminals or literal keywords within a parser rule sequence (e.g., between `'Agent'` and `QualifiedName` in the `AgentDefinition` rule). Newlines (`NL`), also hidden, primarily act as statement or line terminators and are crucial for the lexer's indentation analysis. This EBNF does not explicitly notate `WS?` or `WS*` between all elements, as this is implied by the hidden terminal definition.

### 2.3 Common Terminals
```ebnf
IDENTIFIER ::= /[A-Z]([A-Za-z0-9-]|(\s(?=[A-Z0-9])))*/ // Defined in Section 4.1.
ATOM ::= /:([_a-zA-Z][\w_]*|"[^"\\]*")/ // e.g., :symbol or :"quoted symbol".
STRING ::= /"(\\.|[^"\\])*"/           // Double-quoted strings with standard escape sequences.
NUMBER ::= /[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?/ // Integer or floating-point numbers.
TIME_LITERAL ::= /~T\[[0-9]{2}:[0-9]{2}\]/      // Format: ~T[HH:MM].
ISO_DURATION_LITERAL ::= /(P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d+)?S)?)?)|([0-9]+(\.[0-9]+)?s)/ // ISO 8601 duration or simple seconds (e.g., "3.5s").
```

### 2.4 Expression Terminals
The content within these expressions is treated as raw text by the RCL parser.
```ebnf
SINGLE_LINE_EXPRESSION ::= /\$([a-z]*>)\s*[^\r\n]*/     // e.g., $js> console.log('hello'), $> someValue.
MULTI_LINE_EXPRESSION_START ::= /\$([a-z]*>>>)/          // e.g., $ts>>>, $>>>.
MULTI_LINE_EXPRESSION_CONTENT ::= /[^]*/                 // Raw content of a multi-line block, terminated by a DEDENT.
```

### 2.5 Multi-line String Terminals
```ebnf
MULTILINE_STRING_CLEAN ::= /\|\s*$/        // Marker: | (at end of line, possibly with trailing whitespace).
MULTILINE_STRING_TRIM ::= /\|-\s*$/         // Marker: |- (at end of line, possibly with trailing whitespace).
MULTILINE_STRING_PRESERVE ::= /\+\|\s*$/    // Marker: +| (at end of line, possibly with trailing whitespace).
MULTILINE_STRING_PRESERVE_ALL ::= /\+\|\+\s*$/ // Marker: +|+ (at end of line, possibly with trailing whitespace).
STRING_CONTENT ::= /[^]*/                   // Raw content of a multi-line string, terminated by a DEDENT.
```

### 2.6 Type Conversion Terminals
```ebnf
// Literals '<', '>', and '|' are used directly in the TypeConversion rule.
TYPE_NAME ::= /[a-zA-Z]+/                   // e.g., phone, email, date (used within TypeConversion rule).
```

## 3. Syntactic Specification (Parser Rules)

### 3.0 Core & Common Rules (Derived from `rcl-common.langium`)

```ebnf
QualifiedName ::= IDENTIFIER ('.' IDENTIFIER)*

BooleanLiteral ::= 'true' | 'false'

SimpleValue ::=
    STRING
    | NUMBER
    | BooleanLiteral
    | ATOM
    | TIME_LITERAL
    | ISO_DURATION_LITERAL

Parameter ::= IDENTIFIER ':' SimpleValue

PropertyAssignment ::= IDENTIFIER ':' Value

ExplicitMap ::=
    '%' '{'
        (PropertyAssignment)*
    '}'

InlineParameterList ::=
    Parameter (',' Parameter)*

Value ::= // Represents a value that can be assigned to a property in an ExplicitMap or used elsewhere.
    SimpleValue
    | ExplicitMap
    | InlineParameterList
    | Ref

Ref ::= IDENTIFIER // This IDENTIFIER references another named entity (AbstractNamedSection).
```

### 3.1 Expression Rules (Derived from `rcl-expressions.langium`)

```ebnf
SingleLineExpression ::= SINGLE_LINE_EXPRESSION

MultiLineExpression ::=
    MULTI_LINE_EXPRESSION_START
    INDENT
    MULTI_LINE_EXPRESSION_CONTENT
    DEDENT

Expression ::= SingleLineExpression | MultiLineExpression

ExpressionValue ::= Expression | SimpleValue // A value can be a direct expression or a simple literal.
```

### 3.2 Multi-line String Rules (Derived from `rcl-strings.langium`)

```ebnf
MultiLineString ::=
    ( MULTILINE_STRING_CLEAN
    | MULTILINE_STRING_TRIM
    | MULTILINE_STRING_PRESERVE
    | MULTILINE_STRING_PRESERVE_ALL
    )
    INDENT
    STRING_CONTENT
    DEDENT

EnhancedSimpleValue ::= // Used where a simple value or a multi-line string is acceptable.
    STRING
    | NUMBER
    | BooleanLiteral
    | ATOM
    | TIME_LITERAL
    | ISO_DURATION_LITERAL
    | MultiLineString
```

### 3.3 Type Conversion Rules (Derived from `rcl-types.langium`)

```ebnf
TypeConversionValue ::= STRING | NUMBER | ATOM | IDENTIFIER // The raw value part inside a type conversion tag.

TypeConversion ::=
    '<' TYPE_NAME TypeConversionValue ('|' STRING)? '>' // e.g., <email "user@example.com">, <time "10:00" | "UTC">

TypedValue ::= TypeConversion | EnhancedSimpleValue // A value can be a type conversion or an enhanced simple value (which includes multi-line strings).
```

### 3.4 Main RCL Structure (Derived from `rcl.langium`)

```ebnf
RclFile ::=
    (ImportStatement)*
    AgentDefinition

ImportStatement ::=
    'import' STRING ('as' IDENTIFIER)? ';'

AgentDefinition ::=
    'Agent' QualifiedName
    INDENT
    ('displayName' ':' STRING) // agent-config.schema.json requires displayName for the top-level agent object.
    ('brandName' ':' STRING)? // Optional (read-only in schema after agent verification, but potentially settable during initial creation via API).
    (ConfigSection)?
    (DefaultsSection)?
    (EnhancedFlowSection)+ // At least one flow is required for a functional agent.
    MessagesSection // Mandatory in RCL as per language design for a useful agent.
    DEDENT

DefaultsSection ::=
    'Defaults'
    INDENT
    ( DefaultProperty )* // Zero or more default properties, order not strictly fixed here.
    DEDENT

DefaultProperty ::=
    ('fallback_message' ':' EnhancedSimpleValue)
    | ('messageTrafficType' ':' ATOM)
    | ('ttl' ':' ISO_DURATION_LITERAL)
    | ('postbackData' ':' Expression) // As per plan.
    | ('expressions' INDENT ('language' ':' ATOM) DEDENT) // As per plan.
    | ('timeZone' ':' (STRING | Expression) ) // As per plan.

MessagesSection ::=
    'Messages'
    INDENT
    (AgentMessage | MessageShortcut)+ // One or more messages or shortcuts.
    DEDENT
```

### 3.5 Flow System Rules (Derived from `rcl-flows.langium`)
_Note on Precedence:_ In `EnhancedFlowRule`, the arrow sequence `FlowOperandOrExpression ('->' FlowOperandOrExpression)+` is parsed as a complete unit. The `EnhancedWithClause`, if present, applies to this entire preceding arrow sequence.
```ebnf
EnhancedFlowSection ::=
    'flow' IDENTIFIER // Name of the flow.
    INDENT
    (EnhancedFlowRule)*
    DEDENT

EnhancedFlowRule ::=
    FlowOperandOrExpression ('->' FlowOperandOrExpression)+ // One or more steps in the rule.
    (EnhancedWithClause)?

FlowOperand ::= ATOM | IDENTIFIER | STRING // Literal operands in a flow.

FlowActionText ::= 'text' EnhancedSimpleValue // A direct text output action in a flow.

FlowOperandOrExpression ::=
    FlowOperand
    | FlowActionText
    | Expression
    | ('ref' IDENTIFIER) // Reference to another named section (e.g., another flow).

EnhancedWithClause ::=
    'with' EnhancedParameter (',' EnhancedParameter)*

EnhancedParameter ::= IDENTIFIER ':' ExpressionValue // Parameter name and its value (can be an expression).
```

### 3.6 Agent Configuration Rules (Derived from `rcl-agent-config.langium`)
Properties within this section map to `rcsBusinessMessagingAgent` in `agent-config.schema.json`.
```ebnf
ConfigSection ::=
    'Config'
    INDENT
    ( ConfigProperty )* // Zero or more config properties, order not strictly fixed here.
    DEDENT

ConfigProperty ::=
    ('description' ':' EnhancedSimpleValue) // Optional in schema.
    | ('logoUri' ':' STRING) // Optional in schema.
    | ('heroUri' ':' STRING) // Optional in schema.
    | PhoneNumberProperty
    | EmailProperty
    | WebsiteProperty
    | PrivacyProperty // Optional WebEntry in schema.
    | TermsConditionsProperty // Optional WebEntry in schema.
    | ('color' ':' STRING) // Optional in schema; hex color, validation is semantic.
    | BillingConfigProperty // Optional in schema.
    | ('agentUseCase' ':' ATOM)? // Optional in RCL (schema for RcsBusinessMessagingAgent does not list as required; AgentUseCase enum includes AGENT_USE_CASE_UNSPECIFIED, API defaults if omitted).
    | ('hostingRegion' ':' ATOM)? // Optional in RCL (schema for RcsBusinessMessagingAgent does not list as required; HostingRegion enum includes HOSTING_REGION_UNSPECIFIED, API defaults if omitted).

PhoneNumberProperty ::=
    'phoneNumberEntry'
    INDENT
    ('number' ':' TypedValue) // PhoneEntry.number is required by schema.
    ('label' ':' EnhancedSimpleValue)? // Optional.
    DEDENT

EmailProperty ::=
    'emailEntry'
    INDENT
    ('address' ':' TypedValue) // EmailEntry.address is required by schema.
    ('label' ':' EnhancedSimpleValue)? // Optional.
    DEDENT

WebsiteProperty ::=
    'websiteEntry'
    INDENT
    ('url' ':' TypedValue) // WebEntry.url is required by schema.
    ('label' ':' EnhancedSimpleValue)? // Optional.
    DEDENT

PrivacyProperty ::= // Represents the privacy policy link.
    'privacy'
    INDENT
    ('url' ':' TypedValue) // WebEntry.url is required by schema for the entry.
    ('label' ':' EnhancedSimpleValue)? // Optional.
    DEDENT

TermsConditionsProperty ::= // Represents the terms and conditions link.
    'termsConditions'
    INDENT
    ('url' ':' TypedValue) // WebEntry.url is required by schema for the entry.
    ('label' ':' EnhancedSimpleValue)? // Optional.
    DEDENT

BillingConfigProperty ::=
    'billingConfig'
    INDENT
    ('billingCategory' ':' ATOM)? // Optional in RCL (RcsBusinessMessagingAgentBillingConfig schema requires billingCategory, but its BillingCategory enum includes BILLING_CATEGORY_UNSPECIFIED, allowing API to default if omitted in generated JSON).
    DEDENT
```

### 3.7 Agent Message Rules (Derived from `rcl-agent-message.langium`)
Each keyword-introduced block implies an `INDENT`/`DEDENT` pair if it contains further structured properties on new lines. Schema references (`agent-message.schema.json`) indicate underlying data constraints.

```ebnf
AgentMessage ::=
    'agentMessage' (IDENTIFIER)? // Optional name for the message.
    INDENT
    ('messageTrafficType' ':' ATOM)? // Optional in RCL if defined in Defaults; agent-message.schema.json requires it (API may use MESSAGE_TRAFFIC_TYPE_UNSPECIFIED if this field is omitted in generated JSON and not resolved from Defaults).
    ( ('expireTime' ':' STRING) 
    | ('ttl' ':' ISO_DURATION_LITERAL) )? // Optional, oneOf expireTime/ttl by schema.
    ContentMessage // Required by agent-message.schema.json for AgentMessage.
    DEDENT

ContentMessage ::=
    'contentMessage'
    INDENT
    // One of the following content types is required by agent-message.schema.json for AgentContentMessage.
    ( ('text' ':' (EnhancedSimpleValue | ExpressionValue) )
    | ('fileName' ':' STRING)
    | ('uploadedRbmFile' UploadedRbmFile)
    | ('richCard' RichCard)
    | ('contentInfo' ContentInfo)
    )
    (Suggestion)* // Optional suggestions, max 11 by schema.
    DEDENT

Suggestion ::=
    'suggestion'
    INDENT
    // One of reply or action is required by agent-message.schema.json for Suggestion.
    ( ('reply' SuggestedReply)
    | ('action' SuggestedAction)
    )
    DEDENT

SuggestedReply ::= InlineParameterList // agent-message.schema.json SuggestedReply requires `text` and `postbackData`.
                                      // `postbackData` auto-generated if not in InlineParameterList; `text` is expected to be provided.

SuggestedAction ::=
    (InlineParameterList)? // agent-message.schema.json SuggestedAction requires `text` and `postbackData`. `fallbackUrl` is optional.
                           // `postbackData` auto-generated. `text` is expected to be provided (often via shortcut's first arg).
    INDENT
    // One of the following actions is required by agent-message.schema.json for SuggestedAction.
    ( DialAction
    | ViewLocationAction
    | CreateCalendarEventAction
    | OpenUrlAction
    | ShareLocationAction
    | ComposeAction
    )
    DEDENT

DialAction ::= 'dialAction' INDENT ('phoneNumber' ':' TypedValue) DEDENT // `DialAction.phoneNumber` required by schema.

LatLongObject ::= InlineParameterList // agent-message.schema.json ViewLocationAction.latLong requires `latitude` and `longitude`.

ViewLocationAction ::=
    'viewLocationAction'
    INDENT
    ('label' ':' EnhancedSimpleValue)? // Optional `ViewLocationAction.label`.
    // One of `latLong` or `query` is required by schema for ViewLocationAction.
    ( ('latLong' LatLongObject)
    | ('query' ':' EnhancedSimpleValue)
    )
    DEDENT

CreateCalendarEventAction ::= 'createCalendarEventAction' INDENT InlineParameterList DEDENT // Schema requires: `startTime`, `endTime`, `title`, `description`.

ShareLocationAction ::= 'shareLocationAction' // No fields in schema.

OpenUrlAction ::= 'openUrlAction' INDENT ('url' ':' TypedValue) DEDENT // `OpenUrlAction.url` required by schema.

ComposeAction ::=
    'composeAction'
    INDENT
    // One of `composeTextMessage` or `composeRecordingMessage` required by schema.
    ( ComposeTextMessage
    | ComposeRecordingMessage
    )
    DEDENT

ComposeTextMessage ::= 'composeTextMessage' INDENT InlineParameterList DEDENT // Schema requires: `phoneNumber`, `text`.

ComposeRecordingMessage ::= 'composeRecordingMessage' INDENT InlineParameterList DEDENT // Schema requires: `phoneNumber`, `type`. (`type` in schema has COMPOSE_RECORDING_ACTION_TYPE_UNSPECIFIED option, making it effectively optional in RCL if its 'type' parameter is omitted from InlineParameterList, allowing API to default to UNSPECIFIED).

UploadedRbmFile ::= ExplicitMap | InlineParameterList // Schema requires: `fileName`. Optional: `thumbnailUrl`, `thumbnailName`.

ContentInfo ::= ExplicitMap | InlineParameterList // Schema requires: `fileUrl`. Optional: `thumbnailUrl`, `forceRefresh`, `altText`.

RichCard ::=
    'richCard'
    INDENT
    // One of `standaloneCard` or `carouselCard` required by schema.
    ( StandaloneCard
    | CarouselCard
    )
    DEDENT

StandaloneCard ::=
    'standaloneCard'
    INDENT
    ('cardOrientation' ':' ATOM)? // Optional in RCL (schema requires `cardOrientation`, but has CARD_ORIENTATION_UNSPECIFIED default; API applies default if omitted in generated JSON).
    ('thumbnailImageAlignment' ':' ATOM)? // Optional in RCL (schema optional, has THUMBNAIL_IMAGE_ALIGNMENT_UNSPECIFIED default; API applies default if omitted in generated JSON).
    CardContent // Required by schema.
    DEDENT

CarouselCard ::=
    'carouselCard'
    INDENT
    ('cardWidth' ':' ATOM)? // Optional in RCL (schema requires `cardWidth`, but has CARD_WIDTH_UNSPECIFIED default; API applies default if omitted in generated JSON).
    CardContent CardContent+ // Schema: `minItems`: 2, `maxItems`: 10.
    DEDENT

CardContent ::=
    'cardContent'
    INDENT
    ('title' ':' EnhancedSimpleValue)? // Optional in schema.
    ('description' ':' EnhancedSimpleValue)? // Optional in schema.
    (Media)? // Optional in schema.
    (CardSuggestion)* // Optional suggestions, max 4 per schema.
    DEDENT

CardSuggestion ::= // Structurally same as Suggestion but in Card context.
    'suggestion'
    INDENT
    ( ('reply' SuggestedReply)
    | ('action' SuggestedAction)
    )
    DEDENT

Media ::=
    'media'
    INDENT
    ('height' ':' ATOM)? // Optional in RCL (schema requires `height`, but has HEIGHT_UNSPECIFIED default; API applies default if omitted in generated JSON).
    // One of `file` or `contentInfo` required by schema.
    ( ('file' UploadedRbmFile)
    | ('contentInfo' ContentInfo)
    )
    DEDENT
```

### 3.8 RCS Spec Shortcut Rules (Derived from `rcl-shortcuts.langium`)
These rules describe syntactic sugar. Their transformation into full structures (like `AgentMessage`) is a separate semantic process. `postbackData` for suggestions is assumed to be auto-generated if not explicitly part of a shortcut's arguments. Required fields from the `agent-message.schema.json` (referred to as "schema" in comments) are made syntactically required in the shortcut where practical and noted in comments.

```ebnf
MessageShortcut ::= TextShortcut | FileShortcut | RichCardShortcut // Alternatives to AgentMessage.

TextShortcut ::=
    'text' (EnhancedSimpleValue | ExpressionValue) // Corresponds to AgentContentMessage.text (required by schema for a text message).
    ( INDENT (SuggestionShortcut)* DEDENT )?

FileShortcut ::=
    'uploadedRbmFile' STRING (STRING)? // STRING_1: fileName (UploadedRbmFile.fileName - required by schema). STRING_2 (optional): UploadedRbmFile.thumbnailName.
    ( INDENT (SuggestionShortcut)* DEDENT )?

RichCardShortcut ::=
    'richCard' EnhancedSimpleValue // title (CardContent.title - though optional in schema, made syntactically required for shortcut usability).
    (EnhancedSimpleValue)?       // optional description (CardContent.description - optional in schema).
    ( INDENT
        (Media)?                 // Optional Media (CardContent.media - optional in schema).
        (SuggestionShortcut)*    // Optional suggestions (CardContent.suggestions - optional in schema, max 4).
      DEDENT
    )?
    // This shortcut implies a StandaloneCard. StandaloneCard.cardContent is required by schema (and is constructed from these arguments).
    // StandaloneCard.cardOrientation and Media.height (if Media is present) would default if not specified, relying on UNSPECIFIED values if applicable, or semantic checks.

SuggestionShortcut ::= // Alternatives to the content part of a Suggestion rule.
    ReplyShortcut
    | DialShortcut
    | OpenUrlShortcut
    | ShareLocationShortcut
    | CreateCalendarEventShortcut
    | ViewLocationShortcut

ReplyShortcut ::= 'reply' EnhancedSimpleValue (STRING)? // EnhancedSimpleValue: text (SuggestedReply.text - required by schema). STRING (optional): postbackData (auto-generated if omitted).

DialShortcut ::= 'dial' EnhancedSimpleValue TypedValue // EnhancedSimpleValue: text (SuggestedAction.text - required by schema). TypedValue: phoneNumber (DialAction.phoneNumber - required by schema).

OpenUrlShortcut ::=
    'openUrl' EnhancedSimpleValue TypedValue // EnhancedSimpleValue: text (SuggestedAction.text - required by schema). TypedValue: url (OpenUrlAction.url - required by schema).
    (EnhancedSimpleValue)?                 // Optional description (user-defined for shortcut button context, not a direct schema field of OpenUrlAction).
    ( (':BROWSER' | ':WEBVIEW') ( (':FULL' | ':HALF' | ':TALL') )? )? // viewMode, optional size (platform specific interpretation).

ShareLocationShortcut ::= 'shareLocation' EnhancedSimpleValue // EnhancedSimpleValue: text (SuggestedAction.text - required by schema).

CreateCalendarEventShortcut ::=
    'createCalendarEvent' EnhancedSimpleValue // EnhancedSimpleValue: text (SuggestedAction.text - required by schema).
    INDENT
    'event' EnhancedSimpleValue TypedValue TypedValue EnhancedSimpleValue // Positional args map to: 
                                                                        // 1. title (CreateCalendarEventAction.title - required by schema).
                                                                        // 2. startTime (CreateCalendarEventAction.startTime - required by schema, as TypedValue).
                                                                        // 3. endTime (CreateCalendarEventAction.endTime - required by schema, as TypedValue).
                                                                        // 4. description (CreateCalendarEventAction.description - required by schema).
    DEDENT

ViewLocationShortcut ::=
    'viewLocation' EnhancedSimpleValue // EnhancedSimpleValue: text (SuggestedAction.text - required by schema).
    INDENT
    // One of latLng or query is required by ViewLocationAction schema.
    (   (('latLng' NUMBER NUMBER))      // NUMBER_1: latitude, NUMBER_2: longitude (ViewLocationAction.latLong - required for this choice by schema).
    |   (('query' ':' EnhancedSimpleValue)) // query (ViewLocationAction.query - required for this choice by schema).
    )
    ('label' ':' EnhancedSimpleValue)?    // optional label (ViewLocationAction.label - optional in schema).
    DEDENT
```

## 4. Identifier Rules

### 4.1 Valid Identifier Definition (Lexical Rule: `IDENTIFIER`)

Identifiers are names used for variables, functions, sections, and other named entities within RCL.

-   **Start**: Must start with an uppercase letter (A-Z).
-   **Subsequent Characters**: Can be uppercase letters (A-Z), lowercase letters (a-z), numbers (0-9), or hyphens (`-`).
-   **Spaces**: Allowed within an identifier, but only if the character immediately following the space is an uppercase letter or a number. (e.g., `User ID`, `Order Number 123`).
-   **Hyphens**: Allowed but cannot be preceded or followed by a space. Must be part of a continuous sequence of non-space characters (e.g., `Calculate-Total-Amount`).
-   **Case Sensitivity**: Identifiers are case-sensitive.
-   **Reserved Names**: System-level primary keywords (like `Agent`, `Config`, `Defaults`, `Messages`, `flow` when used to start a section) cannot be used as IDENTIFIERs if it creates ambiguity with the grammar structure. However, these words *may appear within* a valid IDENTIFIER (e.g., `My Config Settings`, `Default Flow Start`). Validation rules ensure clarity.

### 4.2 Examples of Valid Identifiers:
```
MyVariable
CustomerName
ProcessOrder
User ID
Order Number 123
Calculate-Total-Amount
Is Active User
URL-Validator
ItemCount
Primary Config
Main Flow
```

## 5. Type System

### 5.1 Built-in Type Conversions (Syntax Rule: `TypeConversion`)
RCL supports explicit type conversion syntax for certain values.
```ebnf
// Rule defined in 3.3:
// TypeConversion ::= '<' TYPE_NAME TypeConversionValue ('|' STRING)? '>'
// Examples:
// <email "user@example.com">
// <phone "+1234567890">
// <time "14:30" | "Europe/Berlin">
// <date "2024-07-26">
```
The `TYPE_NAME` terminal captures the type keyword (e.g., "email", "phone"). The semantic validity of the `TYPE_NAME` and the `TypeConversionValue` against the specified type, including timezone handling, is subject to semantic validation handled by language services, not purely by this EBNF.

### 5.2 Supported Types (Semantic Interpretation)
The following type names are recognized by the RCL system for validation and potential transformation:
-   `email`: Validates email format.
-   `phone`/`msisdn`: Validates and potentially formats phone numbers.
-   `url`: Validates URL format.
-   `time`: Parses time, with optional timezone support via the `| STRING` syntax.
-   `datetime`/`date`: Parses dates, with optional timezone or formatting hints.
-   `zipcode`/`zip`: Validates postal codes, potentially with country context.

## 6. Indentation and Layout

-   **Indentation Significance**: RCL is indentation-sensitive. `INDENT` and `DEDENT` tokens, generated by the lexer, define the structure of blocks.
-   **Lexer Responsibility**: The lexer is responsible for:
    -   Tracking the current indentation level.
    -   Emitting `INDENT` when indentation increases significantly relative to the parent block.
    -   Emitting `DEDENT` when indentation decreases, potentially emitting multiple `DEDENT` tokens if un-indenting multiple levels.
    -   Handling newlines (`NL`) and whitespace (`WS`) between tokens.
    -   The precise algorithm for `INDENT`/`DEDENT` generation (e.g., how many spaces constitute a new level, consistent use of spaces vs. tabs) is a lexer implementation detail. Consistent use of spaces (e.g., 2 or 4 spaces per level) is strongly recommended for readability and predictable lexer behavior.
-   **Blank Lines**: Blank lines (containing only `WS` and/or `NL` tokens) are typically ignored in terms of structural parsing, except where they might terminate a preceding construct if the language defines such a rule (not explicitly the case in RCL general block structure, which relies on `DEDENT`).

## 7. Expression System

### 7.1 Expression Syntax (Lexical Tokens: `SINGLE_LINE_EXPRESSION`, `MULTI_LINE_EXPRESSION_START`, `MULTI_LINE_EXPRESSION_CONTENT`)
RCL allows embedding expressions in specified parts of the language.
-   **Single-line**: Starts with `$` followed by an optional language identifier (e.g., `js`, `ts`) and `>`, then the expression code on the same line. Examples: `$js> context.user.name`, `$> someDefaultExpression()`.
-   **Multi-line**: Starts with `$` followed by an optional language identifier and `>>>`, then an indented block of code. Examples:
    ```rcl
    $ts>>>
        let x = 10;
        return x * 2;
    ```
### 7.2 Content Handling
The RCL parser treats the content of these expressions as opaque strings (captured by `SINGLE_LINE_EXPRESSION` or `MULTI_LINE_EXPRESSION_CONTENT`). The actual parsing, validation, and execution of the expression code (e.g., as JavaScript/TypeScript) are responsibilities of a separate expression evaluation engine or transpilation step, not the RCL grammar itself.

### 7.3 Available Context (Semantic)
Semantically, when these expressions are evaluated, they are expected to have access to:
-   A `context` variable (providing information about the current flow, state, user data, etc.).
-   A set of `RclUtils` global utility functions.
-   Standard features of the target expression language (e.g., ECMAScript 6 for JavaScript).

## 8. Multi-line String System

### 8.1 String Variants and Markers (Lexical Tokens: `MULTILINE_STRING_CLEAN`, etc.)
RCL supports several syntaxes for multi-line string literals, primarily differing in whitespace handling.
-   `|` (`MULTILINE_STRING_CLEAN`): Typically trims common leading whitespace from each line (based on the indentation of the least indented line within the block or the marker's own column) and results in a single newline at the end of the entire string.
-   `|-` (`MULTILINE_STRING_TRIM`): Similar to `|`, but ensures no trailing newline at the end of the entire string.
-   `+|` (`MULTILINE_STRING_PRESERVE`): Preserves leading whitespace relative to the marker's column and ensures a single newline at the end.
-   `+|+` (`MULTILINE_STRING_PRESERVE_ALL`): Preserves all whitespace, including leading and trailing newlines exactly as they appear in the indented block.

### 8.2 Content Handling
The content of multi-line strings (captured by `STRING_CONTENT`) is determined by the indented block following the marker, up to the corresponding `DEDENT`. The lexer and parser work together to capture this content, with whitespace processing rules applied semantically based on the chosen marker during a later transformation or interpretation phase.

## 9. Further Considerations and Out-of-Scope Items for EBNF

-   **Operator Precedence within Embedded Expressions**: Precedence of operators *within* the embedded expression code (e.g., in `$js> a + b * c`) is governed by the rules of that specific expression language (e.g., JavaScript), not by RCL's EBNF grammar.
-   **Ambiguity Resolution in EBNF Alternatives**: Where grammar rules present alternatives (e.g., `A | B`), standard EBNF does not specify how ambiguities are resolved. Parsers typically try to match alternatives in the order listed, use mechanisms like longest match, or require grammar refactoring (e.g., left-factoring) to eliminate ambiguities for certain parser types (like LL(k)). This specification assumes the grammar is or will be made unambiguous for the chosen parsing technology.
-   **Error Recovery**: Strategies for parsing malformed RCL documents (error recovery) are parser implementation details (e.g., panic mode, synchronization tokens) and are not defined in this EBNF syntax specification.
-   **Semantic Validation**: This document focuses on the syntactic structure. Many crucial aspects of RCL are semantic and are handled by other language services (validators), including but not limited to:
    -   Type checking (e.g., ensuring an ATOM used for `messageTrafficType` is a valid known symbol).
    -   Validation of `TYPE_NAME` in `TypeConversion` against a predefined list of supported types.
    -   Validation of values *within* `TypeConversion` (e.g., is `"foo"` a valid string for an `<email>` type?).
    -   Resolution of `Ref` cross-references and ensuring targets exist and are of appropriate types.
    -   Detection of circular dependencies in flows or imports.
    -   Enforcement of constraints from the RCS Business Messaging specification (e.g., character limits, array sizes, required properties within an `InlineParameterList` for a specific action).
    These are handled by dedicated validation services as outlined in the implementation plan.
-   **Transformation of Shortcuts**: The `MessageShortcut` and `SuggestionShortcut` rules define syntax. The process of transforming these shortcuts into their full, equivalent RCL structures (e.g., an `AgentMessage`) is a separate transformation or desugaring step, not part of the core parsing defined by this EBNF.
-   **Deprecated Features**: This specification is based on the final plan (`rcl-implementation-plan-2.md`). Any features marked for deprecation and removal in that plan are intentionally excluded from this syntax specification.

This formal specification, in conjunction with the semantic rules and processing logic defined elsewhere in the RCL language design, provides a comprehensive definition of Rich Communication Language syntax.

## 10. Error Classification (Syntax vs. Semantic)

This section outlines the distinction between syntax errors (violations of this EBNF) and semantic errors (violations of rules beyond pure syntax, often context-dependent or related to external schemas).

### 10.1 Syntax Errors
Syntax errors occur when the input RCL document does not conform to the EBNF rules defined in this specification. The parser will typically be unable to construct a valid Abstract Syntax Tree (AST). Examples include:

-   **Missing or Misplaced Keywords**: e.g., `AgentName` instead of `'Agent' AgentName`.
-   **Incorrect Token Types**: e.g., Using a `NUMBER` where an `IDENTIFIER` is expected for a flow name.
-   **Malformed Terminals**: e.g., An unclosed `STRING` literal like `"Hello world`.
-   **Incorrect Sequence of Elements**: e.g., Defining an `EnhancedWithClause` before the `'->'` in an `EnhancedFlowRule`.
-   **Invalid Block Structure**: e.g., Mismatched `INDENT`/`DEDENT` pairs, or properties not correctly indented under their parent section keyword.
-   **Lexical Errors**: e.g., An `IDENTIFIER` starting with a lowercase letter (violates the `IDENTIFIER` terminal rule), an `ATOM` without a leading colon.
-   **Violation of Cardinality**: e.g., Providing two `displayName` properties in an `AgentDefinition` where only one is allowed (`?` or no quantifier implies one).

### 10.2 Semantic Errors
Semantic errors occur when the RCL document is syntactically correct according to the EBNF, but violates other rules of the language or external constraints. These are typically caught by validators or during other language processing stages (like linking or code generation).

-   **Undefined References**: e.g., `ref NonExistentFlow` where `NonExistentFlow` is not defined anywhere.
-   **Type Mismatches (Beyond Basic Syntax)**: e.g., In `<phone "not-a-number">`, the syntax `<TYPE_NAME STRING>` is valid, but `"not-a-number"` is semantically incorrect for the `phone` type.
-   **Schema Constraint Violations**: 
    -   Exceeding maximum string lengths (e.g., `SuggestedReply` text > 25 characters).
    -   Exceeding array limits (e.g., more than 11 `Suggestion`s in an `AgentContentMessage`).
    -   Invalid `ATOM` values for a specific context (e.g., `messageTrafficType: :NOT_A_VALID_TYPE`).
    -   Missing a schema-required field that RCL made syntactically optional (e.g., omitting `messageTrafficType` from both `AgentMessage` and `DefaultsSection` would be a semantic error upon generation if the API truly requires it).
-   **Circular Dependencies**: e.g., `flow A -> ref B; flow B -> ref A`.
-   **Logical Errors in Expressions**: e.g., `$js> let x = 1 / 0;` is syntactically valid JS but can lead to runtime issues or produce `Infinity`.
-   **Contextual Rule Violations**: e.g., A flow name that is a reserved section name like "Config" (if validation rules disallow this).
-   **Use of Deprecated Features**: If a feature is syntactically allowed but marked as deprecated by semantic validators.
-   **Invalid `TYPE_NAME` in `TypeConversion`**: e.g., `<nonexistenttype "value">`.

This formal specification, in conjunction with the semantic rules and processing logic defined elsewhere in the RCL language design, provides a comprehensive definition of Rich Communication Language syntax. 