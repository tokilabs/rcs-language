/* rcl-grammar.ebnf - Rich Communication Language Grammar in W3C EBNF Notation */

/* ---------------------------------------------------------------------- */
/* Terminal Definitions (Lexical Rules)                                   */
/* ---------------------------------------------------------------------- */
/* These are the fundamental building blocks (tokens) of RCL, recognized  */
/* by the lexer. In the parser rules that follow, these are referenced by */
/* their capitalized names. Their precise character-level definitions     */
/* (e.g., via regular expressions) are maintained in the main language    */
/* specification document.                                                */

/* Basic Character Sets */
UPPERCASE_LETTER ::= [A-Z]
LOWERCASE_LETTER ::= [a-z]
LETTER ::= UPPERCASE_LETTER | LOWERCASE_LETTER
DIGIT ::= [0-9]
HEX_DIGIT ::= DIGIT | [a-f] | [A-F]
HYPHEN ::= '-'
UNDERSCORE ::= '_'
PERIOD ::= '.'
COLON ::= ':'
SINGLE_QUOTE ::= "'"
DOUBLE_QUOTE ::= '"'
BACKSLASH ::= '\\'
SOLIDUS ::= '/'
SPACE ::= #x20
TAB ::= #x09
EOL ::= #xA | #xD /* Line Feed or Carriage Return */

/* Synthetic Indentation Terminals */
INDENT ::= '' /* Marks a significant increase in indentation level; generated by lexer. */
DEDENT ::= '' /* Marks a significant decrease in indentation level; generated by lexer. */

/* Hidden Terminals (Typically ignored by parser between tokens) */
WS_CHAR ::= SPACE | TAB
WS ::= WS_CHAR+
NL ::= EOL+
SL_COMMENT_CHAR ::= [^#xA#xD] /* Any character except EOL */
SL_COMMENT ::= '#' SL_COMMENT_CHAR* (EOL | /* End of input */)

/* Common Terminals */

IDENTIFIER_START_CHAR ::= UPPERCASE_LETTER
IDENTIFIER_REGULAR_CONT_CHAR ::= LETTER | DIGIT | HYPHEN
IDENTIFIER_SPACE_CONDITION_CHAR ::= UPPERCASE_LETTER | DIGIT /* Char that must follow a space */
IDENTIFIER_CONT_UNIT ::= IDENTIFIER_REGULAR_CONT_CHAR | (SPACE IDENTIFIER_SPACE_CONDITION_CHAR)
IDENTIFIER ::= IDENTIFIER_START_CHAR IDENTIFIER_CONT_UNIT*

/* ATOM: /:([_a-zA-Z][\w_]*|"[^"\\]*")/ */
/* For simplicity, \w is approximated as LETTER | DIGIT. Full Unicode categories are complex for EBNF. */
/* Quoted atom content needs to handle escapes if desired, for now simple non-quote char. */
ATOM_UNQUOTED_START_CHAR ::= UNDERSCORE | LETTER
ATOM_UNQUOTED_CONT_CHAR ::= UNDERSCORE | LETTER | DIGIT
ATOM_UNQUOTED_PART ::= ATOM_UNQUOTED_START_CHAR ATOM_UNQUOTED_CONT_CHAR*
ATOM_QUOTED_INNER_CHAR ::= [^"#x5C] /* Not DOUBLE_QUOTE or BACKSLASH */
ATOM_QUOTED_PART ::= DOUBLE_QUOTE ATOM_QUOTED_INNER_CHAR* DOUBLE_QUOTE
ATOM ::= COLON (ATOM_UNQUOTED_PART | ATOM_QUOTED_PART)

/* STRING: /"(\\.|[^"\\])*"/ */
STRING_CHAR_NO_ESCAPE ::= [^"#x5C]  /* Any char except DOUBLE_QUOTE or BACKSLASH */
STRING_HEX_ESCAPE ::= 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
STRING_COMMON_ESCAPE ::= DOUBLE_QUOTE | BACKSLASH | SOLIDUS | 'b' | 'f' | 'n' | 'r' | 't'
STRING_ESCAPE_SEQUENCE ::= BACKSLASH (STRING_COMMON_ESCAPE | STRING_HEX_ESCAPE)
STRING_CONTENT_CHAR ::= STRING_CHAR_NO_ESCAPE | STRING_ESCAPE_SEQUENCE
STRING ::= DOUBLE_QUOTE STRING_CONTENT_CHAR* DOUBLE_QUOTE

/* NUMBER: /[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?/ */
INTEGER_PART ::= DIGIT+
DECIMAL_PART ::= PERIOD INTEGER_PART
SIGN ::= '+' | '-'
EXPONENT_MARKER ::= 'e' | 'E'
EXPONENT_PART ::= EXPONENT_MARKER SIGN? INTEGER_PART
NUMBER ::= INTEGER_PART DECIMAL_PART? EXPONENT_PART?

/* TIME_LITERAL: /~T\\[[0-9]{2}:[0-9]{2}\\]/ */
TIME_LITERAL ::= "'~T['" DIGIT DIGIT COLON DIGIT DIGIT "']'"

/* ISO_DURATION_LITERAL - This is a highly complex regex. */
/* A full EBNF representation would be extremely verbose. */
/* For now, representing as a high-level token. */
/* Detailed validation would be semantic. */
/* Example parts: PnYnMnDTnHnMnS or PnW or Pn.nS (seconds only variant) */
/* A simplified version might look like: */
/* DURATION_DESIGNATOR ::= 'P' */
/* DURATION_YEAR ::= INTEGER 'Y' */
/* DURATION_MONTH ::= INTEGER 'M' */
/* DURATION_WEEK ::= INTEGER 'W' */
/* DURATION_DAY ::= INTEGER 'D' */
/* DURATION_TIME_DESIGNATOR ::= 'T' */
/* DURATION_HOUR ::= INTEGER 'H' */
/* DURATION_MINUTE_IN_TIME ::= INTEGER 'M' */
/* DURATION_SECOND ::= NUMBER 'S' */
/* Note: NUMBER here for potential decimal seconds. */
/* ISO_DURATION_LITERAL ::= DURATION_DESIGNATOR ((DURATION_YEAR? DURATION_MONTH? DURATION_WEEK? DURATION_DAY? (DURATION_TIME_DESIGNATOR (DURATION_HOUR? DURATION_MINUTE_IN_TIME? DURATION_SECOND?)?)?) | (DURATION_WEEK) | (NUMBER 's')) */
/* The above is a structural sketch and doesn't enforce all ISO8601 constraints e.g. T only if time components present. */
/* For the EBNF, we will use a placeholder and assume lexical analysis provides it. */
/* ISO_DURATION_LITERAL ::= /* Complex ISO 8601 duration string, see HTML spec for regex */

/* Expression Terminals */
/* SINGLE_LINE_EXPRESSION: /\$([a-z]*>)\s*[^\r\n]*/
/* This involves a non-greedy match and specific character classes best handled by regex. */
/* For EBNF, we can denote it, but precise char-level is hard. */
EXPRESSION_LANG_TAG_CHAR ::= LOWERCASE_LETTER
EXPRESSION_LANG_TAG ::= EXPRESSION_LANG_TAG_CHAR*
SINGLE_LINE_EXPRESSION_MARKER ::= '$' EXPRESSION_LANG_TAG '>'
SINGLE_LINE_EXPRESSION_CONTENT_CHAR ::= [^#xA#xD] /* Any char except EOL */
SINGLE_LINE_EXPRESSION ::= SINGLE_LINE_EXPRESSION_MARKER WS* SINGLE_LINE_EXPRESSION_CONTENT_CHAR*

/* MULTI_LINE_EXPRESSION_START: /\$([a-z]*>>>)/ */
MULTI_LINE_EXPRESSION_START ::= '$' EXPRESSION_LANG_TAG '>' '>' '>'

/* MULTI_LINE_EXPRESSION_CONTENT ::= /[^]*/ /* Raw content, effectively anything until DEDENT */
/* This is not easily representable at character level in EBNF without context of DEDENT. */
/* It implies the lexer provides this block. */

/* Multi-line String Terminals */
/* MULTILINE_STRING_CLEAN ::= /\|\s*$/ */
MULTILINE_STRING_CLEAN ::= '|' WS* EOL
/* MULTILINE_STRING_TRIM ::= /\|-\s*$/ */
MULTILINE_STRING_TRIM ::= '|' HYPHEN WS* EOL
/* MULTILINE_STRING_PRESERVE ::= /\+\|\s*$/ */
MULTILINE_STRING_PRESERVE ::= '+' '|' WS* EOL
/* MULTILINE_STRING_PRESERVE_ALL ::= /\+\|\+\s*$/ */
MULTILINE_STRING_PRESERVE_ALL ::= '+' '|' '+' WS* EOL

/* STRING_CONTENT ::= /[^]*/ /* Raw content of a multi-line string, until DEDENT */
/* Similar to MULTI_LINE_EXPRESSION_CONTENT, implies lexer provides block. */

/* Type Conversion Terminals */
/* TYPE_NAME ::= /[a-zA-Z]+/ */
TYPE_NAME ::= LETTER+


/* ---------------------------------------------------------------------- */
/* Syntactic Specification (Parser Rules)                                 */
/* ---------------------------------------------------------------------- */

/* Core & Common Rules */

qualifiedName ::= IDENTIFIER ('.' IDENTIFIER)*

booleanLiteral ::= 'true' | 'false'

simpleValue ::=
    STRING
    | NUMBER
    | booleanLiteral
    | ATOM
    | TIME_LITERAL
    | ISO_DURATION_LITERAL

parameter ::= IDENTIFIER ':' simpleValue

propertyAssignment ::= IDENTIFIER ':' value

explicitMap ::=
    '%' '{'
        (propertyAssignment)*
    '}'

inlineParameterList ::=
    parameter (',' parameter)*

value ::= /* Represents a value that can be assigned to a property in an ExplicitMap or used elsewhere. */
    simpleValue
    | explicitMap
    | inlineParameterList
    | ref

ref ::= IDENTIFIER /* This IDENTIFIER references another named entity. */

/* Expression Rules */

singleLineExpression ::= SINGLE_LINE_EXPRESSION

multiLineExpression ::=
    MULTI_LINE_EXPRESSION_START
    INDENT
    MULTI_LINE_EXPRESSION_CONTENT
    DEDENT

expression ::= singleLineExpression | multiLineExpression

expressionValue ::= expression | simpleValue /* A value can be a direct expression or a simple literal. */

/* Multi-line String Rules */

multiLineString ::=
    ( MULTILINE_STRING_CLEAN
    | MULTILINE_STRING_TRIM
    | MULTILINE_STRING_PRESERVE
    | MULTILINE_STRING_PRESERVE_ALL
    )
    INDENT
    STRING_CONTENT
    DEDENT

enhancedSimpleValue ::= /* Used where a simple value or a multi-line string is acceptable. */
    STRING
    | NUMBER
    | booleanLiteral
    | ATOM
    | TIME_LITERAL
    | ISO_DURATION_LITERAL
    | multiLineString

/* Type Conversion Rules */

typeConversionValue ::= STRING | NUMBER | ATOM | IDENTIFIER /* The raw value part inside a type conversion tag. */

typeConversion ::=
    '<' TYPE_NAME typeConversionValue ('|' STRING)? '>' /* e.g., <email "user@example.com"> */

typedValue ::= typeConversion | enhancedSimpleValue /* A value can be a type conversion or an enhanced simple value. */

/* Main RCL Structure */

rclFile ::=
    (importStatement)*
    agentDefinition

importStatement ::=
    'import' STRING ('as' IDENTIFIER)? ';'

agentDefinition ::=
    'Agent' qualifiedName
    INDENT
    ('displayName' ':' STRING) 
    ('brandName' ':' STRING)? 
    (configSection)?
    (defaultsSection)?
    (enhancedFlowSection)+ 
    messagesSection 
    DEDENT

defaultsSection ::=
    'Defaults'
    INDENT
    ( defaultProperty )* 
    DEDENT

defaultProperty ::=
    ('fallback_message' ':' enhancedSimpleValue)
    | ('messageTrafficType' ':' ATOM)
    | ('ttl' ':' ISO_DURATION_LITERAL)
    | ('postbackData' ':' expression) 
    | ('expressions' INDENT ('language' ':' ATOM) DEDENT) 
    | ('timeZone' ':' (STRING | expression) ) 

messagesSection ::=
    'Messages'
    INDENT
    (agentMessage | messageShortcut)+ 
    DEDENT

/* Flow System Rules */
/* Note on Precedence: In enhancedFlowRule, the arrow sequence flowOperandOrExpression ('->' flowOperandOrExpression)+ is parsed as a complete unit. The enhancedWithClause, if present, applies to this entire preceding arrow sequence. */

enhancedFlowSection ::=
    'flow' IDENTIFIER 
    INDENT
    (enhancedFlowRule)*
    DEDENT

enhancedFlowRule ::=
    flowOperandOrExpression ('->' flowOperandOrExpression)+ 
    (enhancedWithClause)?

flowOperand ::= ATOM | IDENTIFIER | STRING 

flowActionText ::= 'text' enhancedSimpleValue 

flowOperandOrExpression ::=
    flowOperand
    | flowActionText
    | expression
    | ('ref' IDENTIFIER) 

enhancedWithClause ::=
    'with' enhancedParameter (',' enhancedParameter)*

enhancedParameter ::= IDENTIFIER ':' expressionValue 

/* Agent Configuration Rules */

configSection ::=
    'Config'
    INDENT
    ( configProperty )* 
    DEDENT

configProperty ::=
    ('description' ':' enhancedSimpleValue) 
    | ('logoUri' ':' STRING) 
    | ('heroUri' ':' STRING) 
    | phoneNumberProperty
    | emailProperty
    | websiteProperty
    | privacyProperty 
    | termsConditionsProperty 
    | ('color' ':' STRING) 
    | billingConfigProperty 
    | ('agentUseCase' ':' ATOM)? 
    | ('hostingRegion' ':' ATOM)? 

phoneNumberProperty ::=
    'phoneNumberEntry'
    INDENT
    ('number' ':' typedValue) 
    ('label' ':' enhancedSimpleValue)? 
    DEDENT

emailProperty ::=
    'emailEntry'
    INDENT
    ('address' ':' typedValue) 
    ('label' ':' enhancedSimpleValue)? 
    DEDENT

websiteProperty ::=
    'websiteEntry'
    INDENT
    ('url' ':' typedValue) 
    ('label' ':' enhancedSimpleValue)? 
    DEDENT

privacyProperty ::= 
    'privacy'
    INDENT
    ('url' ':' typedValue) 
    ('label' ':' enhancedSimpleValue)? 
    DEDENT

termsConditionsProperty ::= 
    'termsConditions'
    INDENT
    ('url' ':' typedValue) 
    ('label' ':' enhancedSimpleValue)? 
    DEDENT

billingConfigProperty ::=
    'billingConfig'
    INDENT
    ('billingCategory' ':' ATOM)? 
    DEDENT

/* Agent Message Rules */

agentMessage ::=
    'agentMessage' (IDENTIFIER)? 
    INDENT
    ('messageTrafficType' ':' ATOM)? 
    ( ('expireTime' ':' STRING)
    | ('ttl' ':' ISO_DURATION_LITERAL) )? 
    contentMessage 
    DEDENT

contentMessage ::=
    'contentMessage'
    INDENT
    ( ('text' ':' (enhancedSimpleValue | expressionValue) )
    | ('fileName' ':' STRING)
    | ('uploadedRbmFile' uploadedRbmFile)
    | ('richCard' richCard)
    | ('contentInfo' contentInfo)
    )
    (suggestion)* 
    DEDENT

suggestion ::=
    'suggestion'
    INDENT
    ( ('reply' suggestedReply)
    | ('action' suggestedAction)
    )
    DEDENT

suggestedReply ::= inlineParameterList 

suggestedAction ::=
    (inlineParameterList)? 
    INDENT
    ( dialAction
    | viewLocationAction
    | createCalendarEventAction
    | openUrlAction
    | shareLocationAction
    | composeAction
    )
    DEDENT

dialAction ::= 'dialAction' INDENT ('phoneNumber' ':' typedValue) DEDENT 

latLongObject ::= inlineParameterList 

viewLocationAction ::=
    'viewLocationAction'
    INDENT
    ('label' ':' enhancedSimpleValue)? 
    ( ('latLong' latLongObject)
    | ('query' ':' enhancedSimpleValue)
    )
    DEDENT

createCalendarEventAction ::= 'createCalendarEventAction' INDENT inlineParameterList DEDENT 

shareLocationAction ::= 'shareLocationAction' 

openUrlAction ::= 'openUrlAction' INDENT ('url' ':' typedValue) DEDENT 

composeAction ::=
    'composeAction'
    INDENT
    ( composeTextMessage
    | composeRecordingMessage
    )
    DEDENT

composeTextMessage ::= 'composeTextMessage' INDENT inlineParameterList DEDENT 

composeRecordingMessage ::= 'composeRecordingMessage' INDENT inlineParameterList DEDENT 

uploadedRbmFile ::= explicitMap | inlineParameterList 

contentInfo ::= explicitMap | inlineParameterList 

richCard ::=
    'richCard'
    INDENT
    ( standaloneCard
    | carouselCard
    )
    DEDENT

standaloneCard ::=
    'standaloneCard'
    INDENT
    ('cardOrientation' ':' ATOM)? 
    ('thumbnailImageAlignment' ':' ATOM)? 
    cardContent 
    DEDENT

carouselCard ::=
    'carouselCard'
    INDENT
    ('cardWidth' ':' ATOM)? 
    cardContent cardContent+ 
    DEDENT

cardContent ::=
    'cardContent'
    INDENT
    ('title' ':' enhancedSimpleValue)? 
    ('description' ':' enhancedSimpleValue)? 
    (media)? 
    (cardSuggestion)* 
    DEDENT

cardSuggestion ::= 
    'suggestion'
    INDENT
    ( ('reply' suggestedReply)
    | ('action' suggestedAction)
    )
    DEDENT

media ::=
    'media'
    INDENT
    ('height' ':' ATOM)? 
    ( ('file' uploadedRbmFile)
    | ('contentInfo' contentInfo)
    )
    DEDENT

/* RCS Spec Shortcut Rules */

messageShortcut ::= textShortcut | fileShortcut | richCardShortcut 

textShortcut ::=
    'text' (enhancedSimpleValue | expressionValue) 
    ( INDENT (suggestionShortcut)* DEDENT )?

fileShortcut ::=
    'uploadedRbmFile' STRING (STRING)? 
    ( INDENT (suggestionShortcut)* DEDENT )?

richCardShortcut ::=
    'richCard' enhancedSimpleValue 
    (enhancedSimpleValue)?       
    ( INDENT
        (media)?                 
        (suggestionShortcut)*    
      DEDENT
    )?

suggestionShortcut ::= 
    replyShortcut
    | dialShortcut
    | openUrlShortcut
    | shareLocationShortcut
    | createCalendarEventShortcut
    | viewLocationShortcut

replyShortcut ::= 'reply' enhancedSimpleValue (STRING)? 

dialShortcut ::= 'dial' enhancedSimpleValue typedValue 

openUrlShortcut ::=
    'openUrl' enhancedSimpleValue typedValue 
    (enhancedSimpleValue)?                 
    ( (':BROWSER' | ':WEBVIEW') ( (':FULL' | ':HALF' | ':TALL') )? )? 

shareLocationShortcut ::= 'shareLocation' enhancedSimpleValue 

createCalendarEventShortcut ::=
    'createCalendarEvent' enhancedSimpleValue 
    INDENT
    'event' enhancedSimpleValue typedValue typedValue enhancedSimpleValue 
    DEDENT

viewLocationShortcut ::=
    'viewLocation' enhancedSimpleValue 
    INDENT
    (   (('latLng' NUMBER NUMBER))      
    |   (('query' ':' enhancedSimpleValue)) 
    )
    ('label' ':' enhancedSimpleValue)?    
    DEDENT 